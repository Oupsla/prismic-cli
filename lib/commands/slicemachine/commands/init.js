import { existsSync, mkdirSync, readFileSync, writeFileSync,  } from "fs";
import fetch from "node-fetch";
import inquirer from "inquirer";
import consola from "consola";
import ora from "ora";
import shell, { cp } from "shelljs";
import path from "path";
import { spawn } from "child_process";
import urljoin from "url-join";
import AdmZip from "adm-zip";
import Mustache from "mustache";
import Helpers from "../../../helpers";
import Repository from "../../repository";
import Authentication from "../../authentication";
import SliceMachine from "../slicemachine";
import createEndpoints from "../misc/createEndpoints";
import { ctx } from "../../../context";
import Prompt from "inquirer/lib/prompts/base";

const renderText = (file, vars) =>
  Mustache.render(
    readFileSync(path.join(__dirname, "..", "misc", "templates", file), "utf8"),
    vars
  );

async function promptForPrismicApp() {
  const question = {
    type: "list",
    name: "choice",
    message:
      "Hey! It seems you already have a Prismic configuration file.\nHow would you like to proceed?\n",
    choices: [
      {
        name: "Don't overwrite my configuration",
        value: "dont"
      },
      {
        name:
          "Create a new Prismic repo anyway (will overwrite your Prismic config file)",
        value: "do"
      }
    ]
  };
  const { choice } = await inquirer.prompt([question]);
  return choice === "do";
}

async function createApp(bootstraper, frameworkName, skipDisplay) {
  if (!skipDisplay) {
    consola.info(`STEP ONE: create a ${frameworkName} app.\nFirst timer? don't worry: basic configuration is fine.\n`)
  }
  const { projectName } = await inquirer.prompt([
    {
      type: "input",
      name: "projectName",
      message: "Where should we create your app? Folder name:",
      validate(value) {
        return new RegExp("^[\\-\\w]+$").test(value)
          ? true
          : "Your project name can only contain alphanumeric characters, underscores or dashes";
      }
    }
  ]);
  return new Promise((resolve, reject) => {
    const [command, args] = bootstraper;
    try {
      const child = spawn(command, [...args, projectName], {
        stdio: "inherit"
      });
      child.on("close", async code => {
        if (code === 0) {
          return resolve(projectName);
        }
        return reject(
          new Error(`Something went wrong with command "${command}"`)
        );
      });
    } catch (e) {
      reject(
        new Error(
          `Could not launch command "${command}".\nIf you are a Windows user, it is likely caused by npx not being installed on your machine.`
        )
      );
    }
  }).catch(err => {
    consola.error(err);
    return new Error();
  });
}

async function createPrismicRepo(customTypes) {
  const domain = await Repository.chooseDomain();
  await Authentication.connect();
  return await Repository.createWithDomain({
    domain,
    customTypes
  });
}

function handleDependencies(manifest, packageManager = 'npm') {
  const { dependencies, devDependencies } = manifest;
  if (dependencies && Array.isArray(dependencies)) {
    const cmd = packageManager === 'npm' ? 'npm i --save' : 'yarn add'
    shell.exec(`${cmd} ${dependencies.join(" ")}`);
  }
  if (devDependencies && Array.isArray(devDependencies)) {
    const cmd = packageManager === 'npm' ? 'npm i --save-dev' : 'yarn add --dev'
    shell.exec(`${cmd} ${devDependencies.join(" ")}`);
  }
}

// Should we prompt or not? Ask Renaud
const SHOULD_PROMPT = false;
const prompt = () => true;

const shouldOverWrite = (action, projectIsBootstrapped) => {
  const { overwrite, bootstrapped } = action;
  return overwrite || (bootstrapped && projectIsBootstrapped);
};

/**
 * If path should always be overwritten or path to file does nor exist
 * Or file exists but it was just boostrapped by npx create-app.
 * Alternatively, prompt the user to decide
 * @param  {Object} action The action as stored in protocol.json
 * @return {Boolean}        Yes or no?
 */
const shouldWritePath = (action, projectIsBootstrapped) => {
  const { zipPath, writePath } = action;
  return (
    shell.test("-e", writePath || zipPath) === false ||
    shouldOverWrite(action, projectIsBootstrapped) ||
    (SHOULD_PROMPT && prompt())
  );
};

/**
 * Takes an array of actions (mainly "write") from protocol
 * and executes them sequentially, based on specification + project boostrapped or not
 * @param  {Zip}  zip            zip instance
 * @param  {Array}  actions        Array of actions to perform over the project
 * @param  {Object}  info        Data generated by project (eg. magic link)
 * @param  {Boolean} isBootstrapped Was the project bootstrapped by us?
 * @return {null}                 No return
 */
function handleActions(zip, actions, info, isBootstrapped) {
  actions.forEach(action => {
    const { template, type: actionType, zipPath } = action;
    if (actionType && actionType === "delete") {
      return zip.deleteFile(zipPath);
    }
    const shouldWrite = shouldWritePath(action, isBootstrapped);
    if (shouldWrite) {
      if (template) {
        // read: if file is a template
        const f = Mustache.render(zip.readAsText(zipPath, "utf8"), info);
        return writeFileSync(zipPath, f, "utf8");
      }
      zip.extractEntryTo(
        zipPath, // entry (path to)
        "./", // targetPath
        true, // maintainEntryPath?
        shouldOverWrite(action, isBootstrapped) // overwrite?
      );
      zip.deleteFile(zipPath);
    }
    return null;
  });
}

function writePrismicConfig(zip, fileName, { domain, base }) {
  const pattern = /http(s)?:\/\/.*(\.cdn)?\..*\..*\/api(\/v2)?/;

  const matches = base
    ? base.match(/(https?:\/\/)(.*)/)
    : ["http://", "prismic-url-not-found"];
  const protocol = matches[1];
  const url = matches[2];

  const f = zip.readAsText(fileName, "utf8");
  const apiBase = `${protocol}${domain}.${url}`;
  const apiUrl = `${apiBase}/api/v2`;
  const documentsUrl = `${apiBase}/documents`;
  zip.deleteFile(fileName);
  writeFileSync(fileName, f.replace(pattern, apiUrl), "utf8");
  return { apiUrl, documentsUrl };
}

function recap(manifest, info, ctx) {
  shell.exec("clear");

  consola.success('SliceMachine project was successfully initialised!')
  if (ctx.SliceMachine.isSetup) {
    const config = readFileSync(path.join(__dirname, '..', 'misc/nuxt.config.mustache'), 'utf8')
    const f = Mustache.render(config, {
      ...manifest,
      ...info
    });
    writeFileSync(path.join(process.cwd(), 'nuxt.config.js'), f)
    consola.success('I rewrote your Nuxt configuration file!')
    consola.info('After trying SliceMachine, make sure to check it out!')
    return
  }

  const additionalDisplay = Mustache.render(manifest.recap, {
    ...manifest,
    ...info
  });

  Helpers.UI.display(`\n\n${additionalDisplay}`);
}

const testProject = (tests, projectPath = "./") =>
  tests.find(e => shell.test(e.arg, `${projectPath}${e.path}`) === true);

async function shouldWrite(file, context, type = "file") {
  const testRes = type === 'file'
    ? shell.test('-f', path.join('.', file)) === false
    : shell.test('-d', path.join('.', file)) === false
  return context.yes
    || testRes
    || await (async () => {
      const question = {
        type: "list",
        name: "choice",
        message: `A ${type} named "${file}" already exists. What should I do?`,
        choices: [{
            name: "Skip (don't overwrite)",
            value: "dont"
          },
          {
            name: "Overwrite",
            value: "do"
          }
        ]
      }
      const {
        choice
      } = await inquirer.prompt([question]);
      return choice === "do"
    })()
}

const DEBUG = false
async function init() {
  const info = {}

  const isBoot = ctx.SliceMachine.bootstrap
  const { yesÂ } = ctx.SliceMachine

  if (yes) {
    consola.info("Running in no-confirm mode: some files might be overridden.")
  }

  const maybeFramework = await (async function handleFrameworks() {
    const spinner = ora("Downloading framework definitions").start();
    const endpoint = urljoin("https://sm-api.now.sh/api", "frameworks")
    const res = await fetch(endpoint)
    spinner.succeed()
    if (res.status !== 200) {
      consola.error(`[SliceMachine/handleFrameworks] Unable to fetch manifests. Error code: ${res.status}`)
      return new Error()
    }
    const frameworks = await res.json()
    const projectTests = frameworks.reduce((acc, { framework, manifest }) => {
      return {
        ...acc,
        [framework]: manifest.projectTests
      }
    }, {})

    const maybeMatchFramework =
      Object.entries(projectTests).find(([_, tests]) => testProject(tests))

    if (!maybeMatchFramework && !DEBUG) {
      consola.error('Init should be launched inside a Next/Nuxt app')
      consola.info('Did you run this command from the right folder?')
      return new Error()
    }
    if (DEBUG) {
      return 'nuxt'
    }
    return (maybeMatchFramework && maybeMatchFramework.length)
      ? maybeMatchFramework[0]
      : new Error()
  })();

  if (!maybeFramework || maybeFramework instanceof Error === true) {
    return consola.info('Exiting...')
  }

  const framework = maybeFramework

  // if (yes) {
    // consola.info("Running in no-confirm mode: some files might be overridden.")
    // if(!yes) {
    //   const question = {
    //     type: "list",
    //     name: "choice",
    //     message: `What would you like to do?`,
    //     choices: [{
    //         name: "Abort (will exit command)",
    //         value: "dont"
    //       },
    //       {
    //         name: "Continue",
    //         value: "do"
    //       }
    //     ]
    //   }
    //   const { choice } = await inquirer.prompt([question]);
    //   if (choice !== 'do') {
    //     return consola.info('Exiting...')
    //   }
    // }
  // }

  const { zip, manifest } = await (async function handleZip() {
    const spinner = ora("Downloading files from server").start();
    const endpoint = urljoin("https://sm-api.now.sh/api", "bootstrap")
    const maybeZipPath = await SliceMachine.downloadSlices(endpoint, {
      framework,
      lib: ctx.SliceMachine.lib || ctx.SliceMachine.library || "vue-essential-slices"
    })

    spinner.succeed();
    if (!maybeZipPath || maybeZipPath instanceof Error === true) {
      consola.error('An error occured while downloading files from server.')
      return { zip: new Error() }
    }
    const zip = new AdmZip(maybeZipPath);
    const manifest = JSON.parse(zip.readAsText("manifest.json"));
    zip.deleteFile("manifest.json");
    return { zip, manifest }
  })();

  if (!zip || zip instanceof Error === true) {
    return consola.info('Exiting...')
  }

  let domain, magicUrl, apiEndpoint
  if (!ctx.SliceMachine.noPrismic) {
    const ct = JSON.parse(zip.readAsText("mergedCustomTypes.json"));
    consola.info('Next: create a fresh Prismic repository')
    const r = await createPrismicRepo(ct)
    domain = r.domain
    magicUrl = r.magicUrl

    const [protocol, base] = ctx.base.split('://')
    if (!protocol || !base) {
      return consola.error(`Base url "${ctx.base}" is invalid: did you forget to specify protocol?`)
    }
    const apiEndpointUrl =
      `https://${domain}.${ctx.base.replace(/^(?:https?:\/\/)?(?:www\.)?/i, '')}/api/v2`

    info.magicUrl = magicUrl
    info.prismicDomain = domain
    apiEndpoint = apiEndpointUrl

  } else if (DEBUG) {
    domain = 'debug-domain'
  }

  info.apiEndpoint = apiEndpoint || ctx.SliceMachine.endpoint

  zip.deleteFile("mergedCustomTypes.json")

  handleDependencies(manifest);

  await (async function handleFiles() {
    const prompts = manifest.prompts || []
    for (const prompt of prompts) {
      const {
        type,
        path,
        strategies
      } = prompt
      const should = await shouldWrite(path, {
        ...manifest,
        ...ctx.SliceMachine,
        yes
      }, type)

      if (should) {
        const entries = zip.getEntries()
          .filter(e => !e.isDirectory && e.entryName.indexOf(path.concat('/')) !== -1)

        if (!existsSync(path)) {
          mkdirSync(path, {
            recursive: true
          })
        }
        for (const entry of entries) {
          const file = zip.readAsText(entry.entryName, 'utf8')
          const f = entry.entryName.indexOf('.template.') !== -1
            ? Mustache.render(file, info)
            : file

          const fileName = entry.entryName.split('.template').join('')
          writeFileSync(fileName, f, "utf8");
        }
      }
    }
  })();

  (function handleSmFile() {
    const sm = {
      libraries: manifest.libraries,
      ...(info.apiEndpoint ? {
        apiEndpoint: info.apiEndpoint
      } : null)
    }
    writeFileSync("sm.json", JSON.stringify(sm), "utf8");
  })();

  return recap(manifest, info, ctx);
  try {


    let domain, magicUrl
    if (!ctx.SliceMachine.skipPrismic) {
      const ct = JSON.parse(zip.readAsText("mergedCustomTypes.json"));
      const r = await createPrismicRepo(ct)
      domain = r.domain
      magicUrl = r.magicUrl
    } else if (DEBUG) {
      domain = 'debug-domain'
    }

    const [protocol, base] = ctx.base.split('://')
    if (!protocol || !base) {
      return consola.error(`Base url "${ctx.base}" is invalid: did you forget to specify protocol?`)
    }
    const apiEndpoint =
      `https://${domain}.${ctx.base.replace(/^(?:https?:\/\/)?(?:www\.)?/i, '')}/api/v2`

    info.magicUrl = magicUrl
    info.prismicDomain = domain
    info.apiEndpoint = apiEndpoint


    // const urls = writePrismicConfig(zip, "sm.json", {
    //   domain,
    //   base: ctx.base
    // })
    // info.newPrismicRepo = urls;

    handleDependencies(manifest);

    zip.deleteFile("mergedCustomTypes.json");
    return recap(manifest, info);

  } catch(e) {
    consola.error(e)
    return null
  }



  try {
    const Endpoints = createEndpoints();
    const endpoint = Endpoints.SliceMachine.boot();
    const maybeZipPath = await SliceMachine.downloadSlices(
      endpoint,
      {
        framework,
        lib: 'vue-essential-slices'
    });

    if (maybeZipPath && maybeZipPath instanceof Error === false) {
      const zip = new AdmZip(maybeZipPath);
      const protocol = JSON.parse(zip.readAsText("info.json"));

      /**
       * Beginning of us starting testing then creating app.
       * If we are in a given project (eg. Nuxt), continue.
       * If not, get bootstraper for given app (eg. Nuxt),
       * launch the command then cd to created directory.
       * If we are in a Nuxt project, everything went fine.
       * If not, we can't continue and exit the process.
       */

      const maybeFail = testProject(protocol.projectTests);
      // This line is not clear and flow should be rethink
      if (!ctx.SliceMachine.skipBootstraper && (maybeFail || ctx.SliceMachine.isNew)) {
        const { bootstraper, frameworkName, projectTests } = protocol;
        const res = await createApp(bootstraper, frameworkName);
        if (res instanceof Error) {
          return Helpers.UI.display("Exiting...");
        }
        info.projectName = res;
        shell.cd(res);
        const failAgain = testProject(projectTests);
        if (failAgain) {
          return Helpers.UI.display(
            `It seems we were not able to cd to your new ${frameworkName} project.\nReason: ${maybeFail.reason}`
          );
        }

        info.isBootstrapped = true;
        shell.exec("clear");
      }

      /** ------
       *  1/3 Beginning of us testing and creating Prismic repository
       ** -------*/

      /**
       *  If project is new or no Prismic config was found or user agreed to override,
       *  parse the custom_types merged with slices, then create Prismic repository.
       *  Then, read prismic config from zip, update it accordingly (domain + base) then write it to fs
       */
      if (
        !ctx.SliceMachine.skipPrismic &&
        (info.isBootstrapped ||
          shell.test('-e', protocol.prismicConfig) === false ||
          (await promptForPrismicApp()))
      ) {

        const congrats = info.isBootstrapped ? `Congrats! Your ${protocol.frameworkName} app is created.\n` : ''
        consola.success(`${congrats}Next step: create a Prismic repository. It will hold your content and pages.`)

        const ct = JSON.parse(zip.readAsText("slices.json"));
        zip.deleteFile("slices.json");
        const { domain, magicUrl } = await createPrismicRepo(ct);
        const urls = writePrismicConfig(zip, "prismic.config.js", {
          domain,
          base: ctx.base
        });
        zip.deleteFile("prismic.config.js");

        info.magicUrl = magicUrl;
        info.prismicDomain = domain;
        info.newPrismicRepo = urls;
      }

      // Handle downloaded files
      // Qucik fix for magil link before re-write

      // handleActions(
      //   zip,
      //   protocol.actions,
      //   info,
      //   info.isBootstrapped || ctx.SliceMachine.override,
      // );

      /**
       * Handle npm dev + dependencies
       */
      Helpers.UI.display(renderText("initStep3.mustache"));
      handleDependencies(protocol);

      zip.extractAllTo("./", true);

      return recap(protocol, info);
    }
    throw new Error(
      "An error occured. We did not manage to query your slices.\nContact us maybe? Now exiting..."
    );
  } catch (e) {
    return Helpers.UI.display(e);
  }
}

export default true;
export { init };
